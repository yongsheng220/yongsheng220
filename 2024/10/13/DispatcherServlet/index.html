<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"right","width":200,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="http://example.com/2024/10/13/DispatcherServlet/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/10/13/DispatcherServlet/","path":"2024/10/13/DispatcherServlet/","title":"DispatcherServlet流程简要分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>DispatcherServlet流程简要分析 | Y0ng's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Y0ng's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-text">作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">流程图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90"><span class="nav-text">调试分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#doGet%E5%85%A5%E5%8F%A3"><span class="nav-text">doGet入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91"><span class="nav-text">请求分发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">映射器和适配器的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getHandler"><span class="nav-text">getHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getHandlerAdapter"><span class="nav-text">getHandlerAdapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyPreHandle"><span class="nav-text">applyPreHandle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ha-handle"><span class="nav-text">ha.handle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyDefaultViewName"><span class="nav-text">applyDefaultViewName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applyPostHandle"><span class="nav-text">applyPostHandle</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93"><span class="nav-text">视图解析渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#processDispatchResult"><span class="nav-text">processDispatchResult</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#render"><span class="nav-text">render</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#resolveViewName"><span class="nav-text">resolveViewName</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#render-1"><span class="nav-text">render</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Y0ng</p>
  <div class="site-description" itemprop="description">花有重开日，人无再少年</div>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/13/DispatcherServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Y0ng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Y0ng's Blog">
      <meta itemprop="description" content="花有重开日，人无再少年">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="DispatcherServlet流程简要分析 | Y0ng's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DispatcherServlet流程简要分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-13 02:13:48" itemprop="dateCreated datePublished" datetime="2024-10-13T02:13:48+08:00">2024-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaSec/" itemprop="url" rel="index"><span itemprop="name">JavaSec</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/logo.png" alt="logo"></p>
<a id="more"></a>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>DispatcherServlet 是 Spring MVC 框架的核心组件，作为一个 <strong>前端控制器</strong>（Front Controller）负责将所有传入的 HTTP 请求分发给适当的处理器（Controller）并协调视图解析和响应生成。它的作用是集中管理 Web 应用中的所有请求调度流程，使得应用能够解耦并保持整洁有序的架构。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p><strong>前端控制器模式的实现</strong>：</p>
<ul>
<li><code>DispatcherServlet</code> 实现了前端控制器模式（Front Controller）即所有客户端请求首先都会经过该Servlet，然后由它进行统一处理。</li>
<li>通过这种集中管理的方式，可以避免每个控制器直接处理请求，从而提高了系统的可维护性和扩展性。</li>
</ul>
<p><strong>请求分发</strong>：</p>
<ul>
<li><code>DispatcherServlet</code> 根据 URL 和请求参数，使用 <strong>HandlerMapping</strong> 找到与请求对应的处理器（通常是控制器类中的某个方法）。</li>
<li>它不仅负责路由请求，还能够处理请求参数的解析、验证等操作。</li>
</ul>
<p><strong>调用处理器</strong>：</p>
<ul>
<li>找到合适的处理器后，<code>DispatcherServlet</code> 使用 <strong>HandlerAdapter</strong> 负责调用处理器（Controller）并将请求数据传递给它。</li>
<li><code>HandlerAdapter</code> 是将请求与控制器方法参数适配的组件，可以处理多种类型的控制器，包括注解式控制器、简单的控制器等。</li>
</ul>
<p><strong>视图解析</strong>：</p>
<ul>
<li>处理器返回视图名称和模型数据后，<code>DispatcherServlet</code> 使用 <strong>ViewResolver</strong> 解析视图（例如 JSP、Thymeleaf 等模板引擎）找到对应的视图模板。</li>
<li>它负责将模型数据注入到视图模板中，最终渲染成 HTML 响应。</li>
</ul>
<p><strong>异常处理与响应生成</strong>：</p>
<ul>
<li><code>DispatcherServlet</code> 还负责处理异常，将错误信息封装为用户友好的响应。</li>
<li><code>DispatcherServlet</code> 将生成的 HTML 或其他类型的响应数据写入 <code>HttpServletResponse</code>，返回给客户端。</li>
</ul>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241010171153287.png" alt="image-20241010171153287"></p>
<p><strong>首先用户发送请求——&gt;DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制</p>
<p><strong>DispatcherServlet——&gt;HandlerMapping</strong>， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一 个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新 的映射策略</p>
<p><strong>DispatcherServlet——&gt;HandlerAdapter</strong>，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器</p>
<p><strong>HandlerAdapter——&gt;处理器功能处理方法的调用</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）</p>
<p><strong>ModelAndView 的逻辑视图名——&gt; ViewResolver</strong>，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策 略模式，很容易更换其他视图技术</p>
<p><strong>View——&gt;渲染</strong>，View 会根据传进来的Model 模型数据进行渲染，此处的Model 实际是一个Map 数据结构，因此 很容易支持其他视图技术</p>
<p><strong>返回控制权给DispatcherServlet</strong>，由DispatcherServlet 返回响应给用户，到此一个流程结束</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241010160411868.png" alt="image-20241010160411868"></p>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><p>控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/thymeleaf&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">thymeleafExample</span><span class="params">(<span class="meta">@RequestParam(&quot;code&quot;)</span> String code, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;thymeleaf/index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图内容</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Thymeleaf Example&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Thymeleaf Example&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;Code: &lt;span th:text=&quot;$&#123;code&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="doGet入口"><a href="#doGet入口" class="headerlink" title="doGet入口"></a>doGet入口</h2><p>servlet处理get请求是doGet方法，所以定位到 DispatcherServlet 的 doGet 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processRequest方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    LocaleContext localeContext = <span class="keyword">this</span>.buildLocaleContext(request);</span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    ServletRequestAttributes requestAttributes = <span class="keyword">this</span>.buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line">    <span class="comment">// 初始化context</span></span><br><span class="line">    <span class="keyword">this</span>.initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// doService</span></span><br><span class="line">        <span class="keyword">this</span>.doService(request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ServletException var16) &#123;</span><br><span class="line">        failureCause = var16;</span><br><span class="line">        <span class="keyword">throw</span> var16;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">        failureCause = var17;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Request processing failed&quot;</span>, var17);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 重置context</span></span><br><span class="line">        <span class="keyword">this</span>.resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.logResult(request, response, (Throwable)failureCause, asyncManager);</span><br><span class="line">        <span class="keyword">this</span>.publishRequestHandledEvent(request, response, startTime, (Throwable)failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心调用doService方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.logRequest(request);</span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        label116:</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String attrName;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!attrNames.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">break</span> label116;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                attrName = (String)attrNames.nextElement();</span><br><span class="line">            &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.cleanupAfterInclude &amp;&amp; !attrName.startsWith(<span class="string">&quot;org.springframework.web.servlet&quot;</span>));</span><br><span class="line"></span><br><span class="line">            attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, <span class="keyword">this</span>.getThemeSource());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line">    RequestPath previousRequestPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parseRequestPath) &#123;</span><br><span class="line">        previousRequestPath = (RequestPath)request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);</span><br><span class="line">        ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 核心 doDispatch分发request请求</span></span><br><span class="line">        <span class="keyword">this</span>.doDispatch(request, response);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parseRequestPath) &#123;</span><br><span class="line">            ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h2><p>doDispatch 方法是真正处理请求的核心方法，重点函数已添加注释，该方法中主要的函数总结为：</p>
<blockquote>
<p>getHandler：获取一个chain，包含：匹配出request中的处理器(即编写的controller) + 对应的拦截器</p>
<p>getHandlerAdapter：获取能执行chain的 处理器适配器</p>
<p>applyPreHandle：调用前置拦截器</p>
<p>ha.handle：调用处理器(controller)</p>
<p>applyDefaultViewName：获取视图名</p>
<p>applyPostHandle：调用后置拦截器</p>
<p>processDispatchResult：视图渲染处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">            Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是不是文件上传类型的request</span></span><br><span class="line">                processedRequest = <span class="keyword">this</span>.checkMultipart(request);</span><br><span class="line">                multipartRequestParsed = processedRequest != request;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据request获取匹配的handler</span></span><br><span class="line">                mappedHandler = <span class="keyword">this</span>.getHandler(processedRequest);</span><br><span class="line">                <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.noHandlerFound(processedRequest, response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 根据handler获取匹配的handlerAdapter</span></span><br><span class="line">                HandlerAdapter ha = <span class="keyword">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">                String method = request.getMethod();</span><br><span class="line">                <span class="keyword">boolean</span> isGet = HttpMethod.GET.matches(method);</span><br><span class="line">                <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">new</span> ServletWebRequest(request,response)).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 应用前置的拦截器</span></span><br><span class="line">                <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">// 真正handle处理，并返回modelAndView对象</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 通过视图的prefix和postfix获取完整的视图名</span></span><br><span class="line">                <span class="keyword">this</span>.applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 应用后置的拦截器</span></span><br><span class="line">                mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var20) &#123;</span><br><span class="line">                dispatchException = var20;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var21) &#123;</span><br><span class="line">                dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, var21);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 处理handler处理的结果，显然就是对ModelAndView 或者 出现的Excpetion处理</span></span><br><span class="line">            <span class="keyword">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var22) &#123;</span><br><span class="line">            <span class="comment">// 对页面渲染完成里调用拦截器中的AfterCompletion方法</span></span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var23) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, var23));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            <span class="comment">// 清除由多个部分组成的请求使用的所有资源</span></span><br><span class="line">            <span class="keyword">this</span>.cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="映射器和适配器的处理"><a href="#映射器和适配器的处理" class="headerlink" title="映射器和适配器的处理"></a>映射器和适配器的处理</h2><h3 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler"></a>getHandler</h3><p>遍历 handlerMappings</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Iterator var2 = <span class="keyword">this</span>.handlerMappings.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            HandlerMapping mapping = (HandlerMapping)var2.next();</span><br><span class="line">            <span class="comment">// 核心方法getHandler</span></span><br><span class="line">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个handlerMappings：处理器映射，保存了每一个处理器可以处理哪些请求的方法的映射信息</p>
<ul>
<li>RequestMappingHandlerMapping：基于注解，如@RequestMapping的请求映射</li>
<li>WelcomePageHandlerMapping：欢迎页面</li>
<li>BeanNameUrlHandlerMapping：根据 Bean 的名称来处理 URL 请求映射</li>
<li>RouterFunctionMapping：用于处理基于函数式编程风格的请求映射，而不是基于注解的方式</li>
<li>SimpleUrlHandlerMapping：简单的URL到控制器的直接映射，通常通过配置文件如application.properties</li>
</ul>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241010180329266.png" alt="image-20241010180329266"></p>
<p>其中的 <strong>RequestMappingHandlerMapping</strong> 在内存马的学习中已经见到过，其保存的就是关于请求的信息</p>
<p>那么 <code>RequestMappingHandlerMapping[&#39;mappingRegistry&#39;][&#39;registry&#39;]</code> 存储的就是对应的 @Controller 信息</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241010182137640.png" alt="image-20241010182137640"></p>
<p>跟进到核心方法：AbstractHandlerMapping#getHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取URI对应的方法</span></span><br><span class="line">    Object handler = <span class="keyword">this</span>.getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = <span class="keyword">this</span>.getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Bean名称或解析处理程序</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String handlerName = (String)handler;</span><br><span class="line">            handler = <span class="keyword">this</span>.obtainApplicationContext().getBean(handlerName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ServletRequestPathUtils.hasCachedPath(request)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initLookupPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取HandlerExecutionChain</span></span><br><span class="line">        HandlerExecutionChain executionChain = <span class="keyword">this</span>.getHandlerExecutionChain(handler, request);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Mapped to &quot;</span> + handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled() &amp;&amp; !DispatcherType.ASYNC.equals(request.getDispatcherType())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Mapped to &quot;</span> + executionChain.getHandler());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 跨域配置</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">            CorsConfiguration config = <span class="keyword">this</span>.getCorsConfiguration(handler, request);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getCorsConfigurationSource() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                CorsConfiguration globalConfig = <span class="keyword">this</span>.getCorsConfigurationSource().getCorsConfiguration(request);</span><br><span class="line">                config = globalConfig != <span class="keyword">null</span> ? globalConfig.combine(config) : config;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.validateAllowCredentials();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            executionChain = <span class="keyword">this</span>.getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executionChain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一、跟进 AbstractHandlerMethodMapping#getHandlerInternal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的URI路径</span></span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.initLookupPath(request);</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"></span><br><span class="line">    HandlerMethod var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据URI路径从mappingRegistry中获取对应的处理方法</span></span><br><span class="line">        HandlerMethod handlerMethod = <span class="keyword">this</span>.lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        var4 = handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据请求路径获取对应的处理方法(即自己写的controller对应的函数)</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241011102807020.png" alt="image-20241011102807020"></p>
<p>二、跟进AbstractHandlerMapping#getHandlerExecutionChain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 创建chain，添加处理方法</span></span><br><span class="line">        HandlerExecutionChain chain = handler <span class="keyword">instanceof</span> HandlerExecutionChain ? (HandlerExecutionChain)handler : <span class="keyword">new</span> HandlerExecutionChain(handler);</span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.adaptedInterceptors.iterator();</span><br><span class="line">    	<span class="comment">// 添加拦截器</span></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = (HandlerInterceptor)var4.next();</span><br><span class="line">            <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">                MappedInterceptor mappedInterceptor = (MappedInterceptor)interceptor;</span><br><span class="line">                <span class="keyword">if</span> (mappedInterceptor.matches(request)) &#123;</span><br><span class="line">                    chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chain.addInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 返回chain对象</span></span><br><span class="line">        <span class="keyword">return</span> chain;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将handler作为初始参数，创建HandlerExecutionChain对象，然后遍历 adaptedInterceptors 集合，该集合里存放的都是拦截器，如果拦截器的类型是 MappedInterceptor，则调用 matches 方法去匹配一下，看一下是否是拦截当前请求的拦截器，如果是，则调用 chain.addInterceptor 方法加入到 HandlerExecutionChain 对象中；如果就是一个普通拦截器，则直接加入到 HandlerExecutionChain 对象中</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241011104209327.png" alt="image-20241011104209327"></p>
<blockquote>
<p>通过一、二成功获取到chain对象</p>
</blockquote>
<h3 id="getHandlerAdapter"><a href="#getHandlerAdapter" class="headerlink" title="getHandlerAdapter"></a>getHandlerAdapter</h3><p>遍历handlerAdapters，匹配出能够支持处理方法的 处理器适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Iterator var2 = <span class="keyword">this</span>.handlerAdapters.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">            HandlerAdapter adapter = (HandlerAdapter)var2.next();</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">&quot;No adapter for handler [&quot;</span> + handler + <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个handlerAdapters：HandlerAdapter的主要作用是根据处理器的类型调用相应的处理器方法。由于处理器的类型可能多种多样，如方法、类、Bean等，因此需要一个适配器来统一处理这些不同类型的处理器。HandlerAdapter就充当了这样的角色，它屏蔽了处理器的具体实现细节，使得DispatcherServlet可以以统一的方式调用处理器。</p>
<ul>
<li>RequestMappingHandlerAdapter：用于适配基于注解的处理器方法，会解析注解中的信息，并调用相应的处理器方法</li>
<li>HandlerFunctionAdapter：用于适配基于函数式编程模型的处理器</li>
<li>HttpRequestHandlerAdapter：用于适配实现了HttpRequestHandler接口的处理器</li>
<li>SimpleControllerHandlerAdapter：用于适配实现了Controller接口的处理器，已被@Controller注解所取代</li>
</ul>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241011115428439.png" alt="image-20241011115428439"></p>
<p>这里获取的就是 RequestMappingHandlerAdapter</p>
<h3 id="applyPreHandle"><a href="#applyPreHandle" class="headerlink" title="applyPreHandle"></a>applyPreHandle</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.interceptorList.size(); <span class="keyword">this</span>.interceptorIndex = i++) &#123;</span><br><span class="line">        HandlerInterceptor interceptor = (HandlerInterceptor)<span class="keyword">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.triggerAfterCompletion(request, response, (Exception)<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历调用 interceptorList 中的拦截器 preHandle 方法</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241011121055925.png" alt="image-20241011121055925"></p>
<h3 id="ha-handle"><a href="#ha-handle" class="headerlink" title="ha.handle"></a>ha.handle</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45480785/article/details/116595206">https://blog.csdn.net/weixin_45480785/article/details/116595206</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RunningSnails/p/17128123.html">https://www.cnblogs.com/RunningSnails/p/17128123.html</a></p>
</blockquote>
<p>handle -&gt; handleInternal -&gt; invokeHandlerMethod</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleInternal(request, response, (HandlerMethod)handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">跟进</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkRequest(request);</span><br><span class="line">    ModelAndView mav;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">/* http session 相关*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mav = <span class="keyword">this</span>.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 核心函数 invokeHandlerMethod</span></span><br><span class="line">        mav = <span class="keyword">this</span>.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心函数 invokeHandlerMethod</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// WebDataBinderFactory --&gt; 工厂类，为目标对象创建一个WebDataBinder实例</span></span><br><span class="line">		<span class="comment">// 1.WebDataBinder继承了DataBinder类，为web请求提供了：参数绑定服务</span></span><br><span class="line">        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取ModelFactory：</span></span><br><span class="line">		<span class="comment">// 2.主要是两个功能，1是在处理器具体处理之前对model进行初始化，2是在处理完请求后对model参数进行更新</span></span><br><span class="line">        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 3.ServletInvocableHandlerMethod继承并扩展了InvocableHandlerMethod</span></span><br><span class="line">        <span class="comment">// 实际的请求处理、参数绑定、处理请求以及返回值处理 都在此处完成;核心对象</span></span><br><span class="line">        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.四个set方法对invocableMethod设置属性</span></span><br><span class="line">        <span class="comment">// 设置参数处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置返回值处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置参数绑定工厂</span></span><br><span class="line">        invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">        <span class="comment">// 设置参数名称发现器</span></span><br><span class="line">        invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 5.创建ModelAndViewContainer，并初始化Model对象，用于保存model和View对象</span></span><br><span class="line">        ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">        <span class="comment">// 将flashmap中的数据设置到model中</span></span><br><span class="line">        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">        <span class="comment">// 使用modelFactory将sessionAttributes和注释了@ModelAttribute的方法的参数设置到model中</span></span><br><span class="line">        modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">        <span class="comment">// 根据配置对ignoreDefaultModelOnRedirect进行设置</span></span><br><span class="line">        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.异步请求相关</span></span><br><span class="line">        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">        asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line">        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">        asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">        asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">        asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">        asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">            Object result = asyncManager.getConcurrentResult();</span><br><span class="line">            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">            asyncManager.clearConcurrentResult();</span><br><span class="line">            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">                String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 7.调用Controller中的具体方法并处理返回值</span></span><br><span class="line">        invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 8.返回ModelAndView对象</span></span><br><span class="line">        <span class="comment">// 处理完请求后的后置处理</span></span><br><span class="line">        <span class="comment">// 调用ModelFactory的updateModel方法更新model，包括设置SessionAttribute和给Model设置BinderResult</span></span><br><span class="line">        <span class="comment">// 根据mavContainer创建了ModelAndView</span></span><br><span class="line">        <span class="comment">// 如果mavContainer里的model是RedirectAttributes类型，则将其设置到FlashMap</span></span><br><span class="line">        <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 完成请求后续处理,并将当前请求置为未激活</span></span><br><span class="line">        webRequest.requestCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要是为以下几步</p>
<ul>
<li>绑定参数</li>
<li>创建ModelAndViewContainer对象</li>
<li>处理器调用</li>
<li>从ModelAndViewContainer中取出ModelAndView对象</li>
</ul>
<p>有错别字的流程图如下</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/2.png" alt="2"></p>
<p>ServletInvocableHandlerMethod#invokeAndHandle</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// controller对应的函数的返回值</span></span><br><span class="line">		Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">		setResponseStatus(webRequest);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 判断返回值是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">				disableContentCachingIfNecessary(webRequest);</span><br><span class="line">				mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">			mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">		Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">			<span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一、跟进 InvocableHandlerMethod#invokeForRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过参数解析器获取参数</span></span><br><span class="line">    Object[] args = <span class="keyword">this</span>.getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doInvoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、跟进 InvocableHandlerMethod#doInvoke</p>
<p>反射调用handler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Method method = <span class="keyword">this</span>.getBridgedMethod();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KotlinDetector.isSuspendingFunction(method) ? CoroutinesUtils.invokeSuspendingFunction(method, <span class="keyword">this</span>.getBean(), args) : method.invoke(<span class="keyword">this</span>.getBean(), args);</span><br><span class="line">    &#125;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241012115331479.png" alt="image-20241012115331479"></p>
<p>在 <code>this.returnValueHandlers.handleReturnValue</code> 处理返回值时，设置controller的return值作为view属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (returnValue <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">    String viewName = returnValue.toString();</span><br><span class="line">    mavContainer.setViewName(viewName);</span><br><span class="line">    <span class="keyword">if</span> (isRedirectViewName(viewName)) &#123;</span><br><span class="line">        mavContainer.setRedirectModelScenario(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241012220502511.png" alt="image-20241012220502511"></p>
<p>最后通过 getModelAndView 获取 ModelAndView 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ModelAndView <span class="title">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">        ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">    <span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取Model对象</span></span><br><span class="line">    ModelMap model = mavContainer.getModel();</span><br><span class="line">    <span class="comment">// 创建ModelAndView对象，包含model和view</span></span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">    <span class="keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">        mav.setView((View) mavContainer.getView());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是不是Redirect</span></span><br><span class="line">    <span class="keyword">if</span> (model <span class="keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">        Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">        <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来观察一下ModelAndView对象，主要有两个主要属性</p>
<ul>
<li>view：返回的视图文件名称，该例为 <code>thymeleaf/index</code></li>
<li>model：是一个map，存储着在controller中通过addAttribute添加的属性，该例为 <code>code =&gt; test123</code></li>
</ul>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241012221148429.png" alt="image-20241012221148429"></p>
<h3 id="applyDefaultViewName"><a href="#applyDefaultViewName" class="headerlink" title="applyDefaultViewName"></a>applyDefaultViewName</h3><p>判断ModelAndView中有没有view属性，换句话就是看你的controller代码中有没有return值，如果没有的话，将调用getDefaultViewName函数，将其返回值作为view属性。确保view属性不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyDefaultViewName</span><span class="params">(HttpServletRequest request, <span class="meta">@Nullable</span> ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">        String defaultViewName = getDefaultViewName(request);</span><br><span class="line">        <span class="keyword">if</span> (defaultViewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mv.setViewName(defaultViewName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进 DefaultRequestToViewNameTranslator#getViewName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String path = ServletRequestPathUtils.getCachedPathValue(request);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.prefix + transformPath(path) + <span class="keyword">this</span>.suffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会将URI path作为视图名称</p>
<h3 id="applyPostHandle"><a href="#applyPostHandle" class="headerlink" title="applyPostHandle"></a>applyPostHandle</h3><p>再次执行拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        HandlerInterceptor interceptor = <span class="keyword">this</span>.interceptorList.get(i);</span><br><span class="line">        interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="视图解析渲染"><a href="#视图解析渲染" class="headerlink" title="视图解析渲染"></a>视图解析渲染</h2><h3 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult"></a>processDispatchResult</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 一般直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="comment">// 核心函数 render</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>跟进核心函数：DispatcherServlet#render</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Determine locale for request and apply it to the response.</span></span><br><span class="line">    <span class="comment">// 国际化设置</span></span><br><span class="line">    Locale locale =</span><br><span class="line">            (<span class="keyword">this</span>.localeResolver != <span class="keyword">null</span> ? <span class="keyword">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">    response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    String viewName = mv.getViewName();</span><br><span class="line">    <span class="keyword">if</span> (viewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to resolve the view name.</span></span><br><span class="line">        <span class="comment">// 核心函数：resolveViewName,获取最匹配的视图解析器</span></span><br><span class="line">        view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">        view = mv.getView();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	...    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 核心函数：render,调用视图解析器去渲染</span></span><br><span class="line">        view.render(mv.getModelInternal(), request, response);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及两个核心函数</p>
<ul>
<li>resolveViewName：获取最匹配的视图解析器</li>
<li>view#render：调用视图解析器去渲染</li>
</ul>
<h4 id="resolveViewName"><a href="#resolveViewName" class="headerlink" title="resolveViewName"></a>resolveViewName</h4><p>一、跟进</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="function"><span class="params">        Locale locale, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.viewResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">            <span class="comment">// 核心</span></span><br><span class="line">            View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历视图解析器，分别调用各个视图解析器的resolveViewName方法根据viewName获取View对象(freemarker是自己多加的)</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241012231003458.png" alt="image-20241012231003458"></p>
<p>在众多视图解析器中，首先进来的是 ContentNegotiatingViewResolver#resolveViewName</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (requestedMediaTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 核心函数</span></span><br><span class="line">        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">        <span class="comment">// 核心函数</span></span><br><span class="line">        View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line">        <span class="keyword">if</span> (bestView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bestView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又是两个核心函数</p>
<p>1、首先通过 getCandidateViews 筛选出 resolveViewName 方法返回值不为null的视图解析器添加到 candidateViews中</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241013000147650.png" alt="image-20241013000147650"></p>
<p>最后返回两个</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241013000626012.png" alt="image-20241013000626012"></p>
<p>2、之后通过 getBestView 拿到最适配的解析器，getBestView中的逻辑是优先返回在 candidateViews 存在重定向动作的 view，接着判断ContentType是否匹配返回最适配的 View</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">getBestView</span><span class="params">(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes, RequestAttributes attrs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是存在Redirect的View</span></span><br><span class="line">    <span class="keyword">for</span> (View candidateView : candidateViews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateView <span class="keyword">instanceof</span> SmartView) &#123;</span><br><span class="line">            SmartView smartView = (SmartView) candidateView;</span><br><span class="line">            <span class="keyword">if</span> (smartView.isRedirectView()) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidateView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据ContentType是否匹配</span></span><br><span class="line">    <span class="keyword">for</span> (MediaType mediaType : requestedMediaTypes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (View candidateView : candidateViews) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(candidateView.getContentType())) &#123;</span><br><span class="line">                MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());</span><br><span class="line">                <span class="keyword">if</span> (mediaType.isCompatibleWith(candidateContentType)) &#123;</span><br><span class="line">                    mediaType = mediaType.removeQualityValue();</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Selected &#x27;&quot;</span> + mediaType + <span class="string">&quot;&#x27; given &quot;</span> + requestedMediaTypes);</span><br><span class="line">                    &#125;</span><br><span class="line">                    attrs.setAttribute(View.SELECTED_CONTENT_TYPE, mediaType, RequestAttributes.SCOPE_REQUEST);</span><br><span class="line">                    <span class="keyword">return</span> candidateView;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后返回ThymeleafView的view对象</p>
<h4 id="render-1"><a href="#render-1" class="headerlink" title="render"></a>render</h4><p>目前已经获取了view对象(ThymeleafView)</p>
<p><img src="https://picgo-1305609125.cos.ap-nanjing.myqcloud.com/JAVA/image-20241013001647040.png" alt="image-20241013001647040"></p>
<p>进入其render函数，调用 renderFragment</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.renderFragment(<span class="keyword">this</span>.markupSelectors, model, request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>renderFragment中首先定义了一大堆的上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">renderFragment</span><span class="params">(Set&lt;String&gt; markupSelectorsToRender, Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//servletContext</span></span><br><span class="line">    ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    String viewTemplateName = <span class="keyword">this</span>.getTemplateName();</span><br><span class="line">    <span class="comment">//获取SpringTemplateEngine引擎</span></span><br><span class="line">    ISpringTemplateEngine viewTemplateEngine = <span class="keyword">this</span>.getTemplateEngine();</span><br><span class="line">    <span class="keyword">if</span> (viewTemplateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; mergedModel = <span class="keyword">new</span> HashMap(<span class="number">30</span>);</span><br><span class="line">        Map&lt;String, Object&gt; templateStaticVariables = <span class="keyword">this</span>.getStaticVariables();</span><br><span class="line">        <span class="keyword">if</span> (templateStaticVariables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergedModel.putAll(templateStaticVariables);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pathVariablesSelector != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; pathVars = (Map)request.getAttribute(pathVariablesSelector);</span><br><span class="line">            <span class="keyword">if</span> (pathVars != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mergedModel.putAll(pathVars);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (model != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mergedModel.putAll(model);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//applicationContext</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">this</span>.getApplicationContext();</span><br><span class="line">        <span class="comment">//requestContext</span></span><br><span class="line">        RequestContext requestContext = <span class="keyword">new</span> RequestContext(request, response, <span class="keyword">this</span>.getServletContext(), mergedModel);</span><br><span class="line">        <span class="comment">//thymeleafRequestContext</span></span><br><span class="line">        SpringWebMvcThymeleafRequestContext thymeleafRequestContext = <span class="keyword">new</span> SpringWebMvcThymeleafRequestContext(requestContext, request);</span><br><span class="line">        addRequestContextAsVariable(mergedModel, <span class="string">&quot;springRequestContext&quot;</span>, requestContext);</span><br><span class="line">        addRequestContextAsVariable(mergedModel, <span class="string">&quot;springMacroRequestContext&quot;</span>, requestContext);</span><br><span class="line">        mergedModel.put(<span class="string">&quot;thymeleafRequestContext&quot;</span>, thymeleafRequestContext);</span><br><span class="line">        ConversionService conversionService = (ConversionService)request.getAttribute(ConversionService.class.getName());</span><br><span class="line">        <span class="comment">//evaluationContext</span></span><br><span class="line">        ThymeleafEvaluationContext evaluationContext = <span class="keyword">new</span> ThymeleafEvaluationContext(applicationContext, conversionService);</span><br><span class="line">        mergedModel.put(<span class="string">&quot;thymeleaf::EvaluationContext&quot;</span>, evaluationContext);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取SpringTemplateEngine配置文件</span></span><br><span class="line">        IEngineConfiguration configuration = viewTemplateEngine.getConfiguration();</span><br><span class="line">        <span class="comment">//通过前面众多context上下文构造出WebExpressionContext</span></span><br><span class="line">        WebExpressionContext context = <span class="keyword">new</span> WebExpressionContext(configuration, request, response, servletContext, <span class="keyword">this</span>.getLocale(), mergedModel);</span><br><span class="line">        </span><br><span class="line">        String templateName;</span><br><span class="line">        Set markupSelectors;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重点：判断模板文件名(return值)是否包含 `::`</span></span><br><span class="line">        <span class="keyword">if</span> (!viewTemplateName.contains(<span class="string">&quot;::&quot;</span>)) &#123;</span><br><span class="line">            templateName = viewTemplateName;</span><br><span class="line">            markupSelectors = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是SSTI漏洞触发点之一，这里先略过</span></span><br><span class="line">            IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration);</span><br><span class="line">            FragmentExpression fragmentExpression;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fragmentExpression = (FragmentExpression)parser.parseExpression(context, <span class="string">&quot;~&#123;&quot;</span> + viewTemplateName + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TemplateProcessingException var25) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid template name specification: &#x27;&quot;</span> + viewTemplateName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FragmentExpression.ExecutedFragmentExpression fragment = FragmentExpression.createExecutedFragmentExpression(context, fragmentExpression);</span><br><span class="line">            templateName = FragmentExpression.resolveTemplateName(fragment);</span><br><span class="line">            markupSelectors = FragmentExpression.resolveFragments(fragment);</span><br><span class="line">            Map&lt;String, Object&gt; nameFragmentParameters = fragment.getFragmentParameters();</span><br><span class="line">            <span class="keyword">if</span> (nameFragmentParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fragment.hasSyntheticParameters()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Parameters in a view specification must be named (non-synthetic): &#x27;&quot;</span> + viewTemplateName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                context.setVariables(nameFragmentParameters);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 不包含 `::` 就跳到这里</span></span><br><span class="line">        String templateContentType = <span class="keyword">this</span>.getContentType();</span><br><span class="line">        <span class="comment">//一些关于ContentType和Encoding的操作</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> producePartialOutputWhileProcessing = <span class="keyword">this</span>.getProducePartialOutputWhileProcessing();</span><br><span class="line">        Writer templateWriter = producePartialOutputWhileProcessing ? response.getWriter() : <span class="keyword">new</span> FastStringWriter(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 核心函数process,thymeleaf便会根据配置的Resolver路径找到模板并解析通过io返回</span></span><br><span class="line">        viewTemplateEngine.process(templateName, processMarkupSelectors, context, (Writer)templateWriter);</span><br><span class="line">        <span class="keyword">if</span> (!producePartialOutputWhileProcessing) &#123;</span><br><span class="line">            response.getWriter().write(templateWriter.toString());</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心函数process作用为thymeleaf会根据配置的Resolver路径找到模板并解析通过io返回，函数代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">final</span> TemplateManager templateManager = <span class="keyword">this</span>.configuration.getTemplateManager();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.找到模板并且处理</span></span><br><span class="line">    templateManager.parseAndProcess(templateSpec, context, writer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> endNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.io刷新到请求页面</span></span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TemplateOutputException(<span class="string">&quot;An error happened while flushing output writer&quot;</span>, templateSpec.getTemplate(), -<span class="number">1</span>, -<span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再跟进 parseAndProcess</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseAndProcess</span><span class="params">(TemplateSpec templateSpec, IContext context, Writer writer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    TemplateResolution templateResolution = resolveTemplate(<span class="keyword">this</span>.configuration, (String)<span class="keyword">null</span>, template, templateResolutionAttributes, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//构建templateData</span></span><br><span class="line">    TemplateData templateData = buildTemplateData(templateResolution, template, templateSelectors, templateMode, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//处理request与response放入到IEngineContext中，处理varilable</span></span><br><span class="line">    IEngineContext engineContext = EngineContextManager.prepareEngineContext(<span class="keyword">this</span>.configuration, templateData, templateResolutionAttributes, context);</span><br><span class="line">    ProcessorTemplateHandler processorTemplateHandler = <span class="keyword">new</span> ProcessorTemplateHandler();</span><br><span class="line">    ITemplateHandler processingHandlerChain = createTemplateProcessingHandlerChain(engineContext, <span class="keyword">true</span>, <span class="keyword">true</span>, processorTemplateHandler, writer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正执行模板解析的工具</span></span><br><span class="line">    ITemplateParser parser = <span class="keyword">this</span>.getParserForTemplateMode(engineContext.getTemplateMode());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (templateResolution.getValidity().isCacheable() &amp;&amp; <span class="keyword">this</span>.templateCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ModelBuilderTemplateHandler builderHandler = <span class="keyword">new</span> ModelBuilderTemplateHandler(<span class="keyword">this</span>.configuration, templateData);</span><br><span class="line">        parser.parseStandalone(<span class="keyword">this</span>.configuration, (String)<span class="keyword">null</span>, template, templateSelectors, templateData.getTemplateResource(), engineContext.getTemplateMode(), templateResolution.getUseDecoupledLogic(), builderHandler);</span><br><span class="line">        TemplateModel templateModel = builderHandler.getModel();</span><br><span class="line">        <span class="keyword">this</span>.templateCache.put(cacheKey, templateModel);</span><br><span class="line">        templateModel.process(processingHandlerChain);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 核心函数，解析模板</span></span><br><span class="line">        parser.parseStandalone(<span class="keyword">this</span>.configuration, (String)<span class="keyword">null</span>, template, templateSelectors, templateData.getTemplateResource(), engineContext.getTemplateMode(), templateResolution.getUseDecoupledLogic(), processingHandlerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EngineContextManager.disposeEngineContext(engineContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parser.parseStandalone最终会调用 AbstractMarkupTemplateParser#parse 方法，有两个关键，一个是读取模板，一个是解析模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取模板，会调用之前绑定的resource解析器</span></span><br><span class="line">Reader templateReader = (resource != <span class="keyword">null</span>? resource.reader() : <span class="keyword">new</span> StringReader(template));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析模板</span></span><br><span class="line">templateReader = <span class="keyword">new</span> ParserLevelCommentMarkupReader(<span class="keyword">new</span> PrototypeOnlyCommentMarkupReader(templateReader));</span><br><span class="line"><span class="keyword">this</span>.parser.parse(templateReader, handler);</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/spring/spring-x-framework-springmvc-source-2.html">https://pdai.tech/md/spring/spring-x-framework-springmvc-source-2.html</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/files/kaitao-springMVC.pdf">https://pdai.tech/files/kaitao-springMVC.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41063182/article/details/103116037">thymeleaf源码解读</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45480785/article/details/116595206">SpringMVC源码学习(六)—解析HandlerMethod执行过程_invokehandlermethod</a></p>
<p><a target="_blank" rel="noopener" href="https://flowerwind.github.io/2021/05/23/SpringMVC%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">SpringMVC源码学习 | huahua’s Blog</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/06/CVE-2024-45519/" rel="prev" title="Zimbra-RCE-分析(CVE-2024-45519)">
                  <i class="fa fa-angle-left"></i> Zimbra-RCE-分析(CVE-2024-45519)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/30/Thymeleaf/" rel="next" title="JAVA-SSTI-Thymeleaf">
                  JAVA-SSTI-Thymeleaf <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Y0ng</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
